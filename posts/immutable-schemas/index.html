<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Immutable Schemas |</title><meta name=keywords content><meta name=description content="Representing data in any application is a difficult problem to solve involving
many different tradeoffs. Let&rsquo;s imagine we want to store information about a
purchase:
CREATE TABLE purchase (
    id BIGINT GENERATED ALWAYS AS IDENTITY,
    purchase_uid UUID NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL,

    CONSTRAINT pk_purchase PRIMARY KEY (id),
    CONSTRAINT uk_purchase_purchase_uid UNIQUE (purchase_uid)
);
At a given point in time, a purchase might be in one of a few states:

Pending (the customer has requested the item)
Settled (the payment has transacted)
Dispatched (the item has been sent for delivery)
Delivered (the customer has the item)

Our first intuition might storing a status column on the table:"><meta name=author content><link rel=canonical href=https://alexander-jackson.github.io/posts/immutable-schemas/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://alexander-jackson.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://alexander-jackson.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://alexander-jackson.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://alexander-jackson.github.io/apple-touch-icon.png><link rel=mask-icon href=https://alexander-jackson.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://alexander-jackson.github.io/posts/immutable-schemas/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://alexander-jackson.github.io/posts/immutable-schemas/"><meta property="og:title" content="Immutable Schemas"><meta property="og:description" content="Representing data in any application is a difficult problem to solve involving many different tradeoffs. Let’s imagine we want to store information about a purchase:
CREATE TABLE purchase ( id BIGINT GENERATED ALWAYS AS IDENTITY, purchase_uid UUID NOT NULL, created_at TIMESTAMP WITH TIME ZONE NOT NULL, CONSTRAINT pk_purchase PRIMARY KEY (id), CONSTRAINT uk_purchase_purchase_uid UNIQUE (purchase_uid) ); At a given point in time, a purchase might be in one of a few states:
Pending (the customer has requested the item) Settled (the payment has transacted) Dispatched (the item has been sent for delivery) Delivered (the customer has the item) Our first intuition might storing a status column on the table:"><meta property="og:locale" content="en-gb"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-11-22T18:24:08+00:00"><meta property="article:modified_time" content="2025-11-22T18:24:08+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Immutable Schemas"><meta name=twitter:description content="Representing data in any application is a difficult problem to solve involving
many different tradeoffs. Let&rsquo;s imagine we want to store information about a
purchase:
CREATE TABLE purchase (
    id BIGINT GENERATED ALWAYS AS IDENTITY,
    purchase_uid UUID NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL,

    CONSTRAINT pk_purchase PRIMARY KEY (id),
    CONSTRAINT uk_purchase_purchase_uid UNIQUE (purchase_uid)
);
At a given point in time, a purchase might be in one of a few states:

Pending (the customer has requested the item)
Settled (the payment has transacted)
Dispatched (the item has been sent for delivery)
Delivered (the customer has the item)

Our first intuition might storing a status column on the table:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://alexander-jackson.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Immutable Schemas","item":"https://alexander-jackson.github.io/posts/immutable-schemas/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Immutable Schemas","name":"Immutable Schemas","description":"Representing data in any application is a difficult problem to solve involving many different tradeoffs. Let\u0026rsquo;s imagine we want to store information about a purchase:\nCREATE TABLE purchase ( id BIGINT GENERATED ALWAYS AS IDENTITY, purchase_uid UUID NOT NULL, created_at TIMESTAMP WITH TIME ZONE NOT NULL, CONSTRAINT pk_purchase PRIMARY KEY (id), CONSTRAINT uk_purchase_purchase_uid UNIQUE (purchase_uid) ); At a given point in time, a purchase might be in one of a few states:\nPending (the customer has requested the item) Settled (the payment has transacted) Dispatched (the item has been sent for delivery) Delivered (the customer has the item) Our first intuition might storing a status column on the table:\n","keywords":[],"articleBody":"Representing data in any application is a difficult problem to solve involving many different tradeoffs. Let’s imagine we want to store information about a purchase:\nCREATE TABLE purchase ( id BIGINT GENERATED ALWAYS AS IDENTITY, purchase_uid UUID NOT NULL, created_at TIMESTAMP WITH TIME ZONE NOT NULL, CONSTRAINT pk_purchase PRIMARY KEY (id), CONSTRAINT uk_purchase_purchase_uid UNIQUE (purchase_uid) ); At a given point in time, a purchase might be in one of a few states:\nPending (the customer has requested the item) Settled (the payment has transacted) Dispatched (the item has been sent for delivery) Delivered (the customer has the item) Our first intuition might storing a status column on the table:\nCREATE TYPE purchase_status AS ENUM ( 'PENDING', 'SETTLED', 'DISPATCHED', 'DELIVERED' ); ALTER TABLE purchase ADD COLUMN status purchase_status NOT NULL; We can then modify the status whenever an action occurs:\nUPDATE purchase SET status = 'DELIVERED' WHERE purchase_uid = '...'; However, if we have a purchase in the DELIVERED status, we have no idea when it was actually delivered. Let’s add another column on the table to store when the status was changed:\nALTER TABLE purchase ADD COLUMN status_changed_at TIMESTAMP WITH TIME ZONE NOT NULL; Every time we modify the status, we update the new field as well:\nUPDATE purchase SET status = 'DELIVERED' status_changed_at = now()::timestamp WHERE purchase_uid = '...'; Historical Data One issue with this approach is that every time we transition the status, we lose information we had before. When we move from DISPATCHED to DELIVERED and update the timestamp, we no longer know when the purchase was dispatched.\nInstead, let’s store a timestamp for each state:\nALTER TABLE purchase DROP COLUMN status, DROP COLUMN status_changed_at; ALTER TABLE purchase ADD COLUMN pending_at TIMESTAMP WITH TIME ZONE NOT NULL, ADD COLUMN settled_at TIMESTAMP WITH TIME ZONE, ADD COLUMN dispatched_at TIMESTAMP WITH TIME ZONE, ADD COLUMN delivered_at TIMESTAMP WITH TIME ZONE; We can make purchase.pending_at non-null since rows will have this from the beginning, but everything else must be nullable. We can then derive the status from these columns:\nINSERT INTO purchase (purchase_uid, created_at, pending_at) VALUES ( 'd3b1ca3e-83b0-432b-81ea-330facdf7f56', '2025-05-04 09:13:54', '2025-05-04 09:13:57' ); INSERT INTO purchase (purchase_uid, created_at, pending_at, settled_at, dispatched_at) VALUES ( 'decff56d-60cb-4368-9995-91768c3081dd', '2025-05-04 10:28:12', '2025-05-04 10:28:14', '2025-05-04 10:30:02', '2025-05-04 21:01:55' ); SELECT purchase_uid, created_at, CASE WHEN delivered_at IS NOT NULL THEN 'DELIVERED' WHEN dispatched_at IS NOT NULL THEN 'DISPATCHED' WHEN settled_at IS NOT NULL THEN 'SETTLED' ELSE 'PENDING' END AS status FROM purchase ORDER BY created_at ASC; This returns the following output:\npurchase_uid | created_at | status --------------------------------------+------------------------+------------ d3b1ca3e-83b0-432b-81ea-330facdf7f56 | 2025-05-04 09:13:54+01 | PENDING decff56d-60cb-4368-9995-91768c3081dd | 2025-05-04 10:28:12+01 | DISPATCHED While this is correct, it’s quite a cumbersome approach:\nWe’re storing lots of null values if purchases don’t progress Since PostgreSQL implements an update as a delete and insert, we might be creating lots of dead rows Our SELECT statement doesn’t even return the status_changed_at equivalent at the moment, we’d need a more complex query for that The table will become quite wide over time Any queries on status will need to use the same logic, leading to duplication Event-based Approach Let’s return to our purchase table definition from the beginning:\nDROP TABLE purchase; CREATE TABLE purchase ( id BIGINT GENERATED ALWAYS AS IDENTITY, purchase_uid UUID NOT NULL, created_at TIMESTAMP WITH TIME ZONE NOT NULL, CONSTRAINT pk_purchase PRIMARY KEY (id), CONSTRAINT uk_purchase_purchase_uid UNIQUE (purchase_uid) ); A nicer model might be to represent each of these changes in state as an event, related to a purchase. We can insert these whenever something happens, such as the item being dispatched or delivered. We’ll need a separate table with a foreign key:\nCREATE TYPE purchase_event_type AS ENUM ( 'PENDING', 'SETTLED', 'DISPATCHED', 'DELIVERED' ); CREATE TABLE purchase_event ( id BIGINT GENERATED ALWAYS AS IDENTITY, purchase_event_uid UUID NOT NULL, purchase_id BIGINT NOT NULL, event_type purchase_event_type NOT NULL, occurred_at TIMESTAMP WITH TIME ZONE NOT NULL, CONSTRAINT pk_purchase_event PRIMARY KEY (id), CONSTRAINT uk_purchase_event_purchase_event_uid UNIQUE (purchase_event_uid), CONSTRAINT fk_purchase_event_purchase_id FOREIGN KEY (purchase_id) REFERENCES purchase (id) ); This gives us a way to represent each change in state as an immutable event. When a purchase is created, we insert a PENDING event:\nINSERT INTO purchase (purchase_uid, created_at) VALUES ( 'd3b1ca3e-83b0-432b-81ea-330facdf7f56', '2025-05-04 09:13:54' ); INSERT INTO purchase_event (purchase_event_uid, purchase_id, event_type, occurred_at) VALUES ( 'a1f5e6d2-4c3b-4e29-9f7c-8b6d5e4f3a2b', (SELECT id FROM purchase WHERE purchase_uid = 'd3b1ca3e-83b0-432b-81ea-330facdf7f56'), 'PENDING', '2025-05-04 09:13:57' ); When the purchase is settled, we insert a SETTLED event:\nINSERT INTO purchase_event (purchase_event_uid, purchase_id, event_type, occurred_at) VALUES ( '0d1d6b08-cdf5-42ef-810d-0bdba31017e2', (SELECT id FROM purchase WHERE purchase_uid = 'd3b1ca3e-83b0-432b-81ea-330facdf7f56'), 'SETTLED', '2025-05-04 10:00:12' ); We can continue this for each event in the purchase lifecycle. To get the current status of a purchase, we can query the latest event:\nSELECT DISTINCT ON (p.purchase_uid) p.purchase_uid, p.created_at, pe.event_type AS status, pe.occurred_at AS status_changed_at FROM purchase p JOIN purchase_event pe ON pe.purchase_id = p.id WHERE p.purchase_uid = 'd3b1ca3e-83b0-432b-81ea-330facdf7f56' ORDER BY p.purchase_uid, pe.occurred_at DESC; We can also list all the events for a given purchase:\nSELECT p.purchase_uid, pe.event_type AS status, pe.occurred_at AS status_changed_at FROM purchase p JOIN purchase_event pe ON pe.purchase_id = p.id WHERE p.purchase_uid = 'd3b1ca3e-83b0-432b-81ea-330facdf7f56' ORDER BY pe.occurred_at; The benefit of this approach is that we maintain a full history of all the changes to a purchase, without losing any information. We can easily provide metrics like how long purchases are taking to be delivered, and we can add new event types in the future without modifying existing data.\n","wordCount":"892","inLanguage":"en","datePublished":"2025-11-22T18:24:08Z","dateModified":"2025-11-22T18:24:08Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://alexander-jackson.github.io/posts/immutable-schemas/"},"publisher":{"@type":"Organization","name":"","logo":{"@type":"ImageObject","url":"https://alexander-jackson.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Immutable Schemas</h1><div class=post-meta><span title='2025-11-22 18:24:08 +0000 UTC'>November 22, 2025</span></div></header><div class=post-content><p>Representing data in any application is a difficult problem to solve involving
many different tradeoffs. Let&rsquo;s imagine we want to store information about a
purchase:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> purchase (
</span></span><span style=display:flex><span>    id BIGINT <span style=color:#66d9ef>GENERATED</span> ALWAYS <span style=color:#66d9ef>AS</span> <span style=color:#66d9ef>IDENTITY</span>,
</span></span><span style=display:flex><span>    purchase_uid UUID <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span>,
</span></span><span style=display:flex><span>    created_at <span style=color:#66d9ef>TIMESTAMP</span> <span style=color:#66d9ef>WITH</span> TIME <span style=color:#66d9ef>ZONE</span> <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>CONSTRAINT</span> pk_purchase <span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span> (id),
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>CONSTRAINT</span> uk_purchase_purchase_uid <span style=color:#66d9ef>UNIQUE</span> (purchase_uid)
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><p>At a given point in time, a purchase might be in one of a few states:</p><ul><li>Pending (the customer has requested the item)</li><li>Settled (the payment has transacted)</li><li>Dispatched (the item has been sent for delivery)</li><li>Delivered (the customer has the item)</li></ul><p>Our first intuition might storing a <code>status</code> column on the table:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TYPE</span> purchase_status <span style=color:#66d9ef>AS</span> ENUM (
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;PENDING&#39;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;SETTLED&#39;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;DISPATCHED&#39;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;DELIVERED&#39;</span>
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>ALTER</span> <span style=color:#66d9ef>TABLE</span> purchase
</span></span><span style=display:flex><span><span style=color:#66d9ef>ADD</span> <span style=color:#66d9ef>COLUMN</span> status purchase_status <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span>;
</span></span></code></pre></div><p>We can then modify the status whenever an action occurs:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>UPDATE</span> purchase
</span></span><span style=display:flex><span><span style=color:#66d9ef>SET</span> status <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;DELIVERED&#39;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>WHERE</span> purchase_uid <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;...&#39;</span>;
</span></span></code></pre></div><p>However, if we have a purchase in the <code>DELIVERED</code> status, we have no idea when
it was actually delivered. Let&rsquo;s add another column on the table to store when
the status was changed:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>ALTER</span> <span style=color:#66d9ef>TABLE</span> purchase
</span></span><span style=display:flex><span><span style=color:#66d9ef>ADD</span> <span style=color:#66d9ef>COLUMN</span> status_changed_at <span style=color:#66d9ef>TIMESTAMP</span> <span style=color:#66d9ef>WITH</span> TIME <span style=color:#66d9ef>ZONE</span> <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span>;
</span></span></code></pre></div><p>Every time we modify the status, we update the new field as well:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>UPDATE</span> purchase
</span></span><span style=display:flex><span><span style=color:#66d9ef>SET</span>
</span></span><span style=display:flex><span>    status <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;DELIVERED&#39;</span>
</span></span><span style=display:flex><span>    status_changed_at <span style=color:#f92672>=</span> now()::<span style=color:#66d9ef>timestamp</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>WHERE</span> purchase_uid <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;...&#39;</span>;
</span></span></code></pre></div><h2 id=historical-data>Historical Data<a hidden class=anchor aria-hidden=true href=#historical-data>#</a></h2><p>One issue with this approach is that every time we transition the status, we
lose information we had before. When we move from <code>DISPATCHED</code> to <code>DELIVERED</code>
and update the timestamp, we no longer know when the purchase was dispatched.</p><p>Instead, let&rsquo;s store a timestamp for each state:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>ALTER</span> <span style=color:#66d9ef>TABLE</span> purchase
</span></span><span style=display:flex><span><span style=color:#66d9ef>DROP</span> <span style=color:#66d9ef>COLUMN</span> status, <span style=color:#66d9ef>DROP</span> <span style=color:#66d9ef>COLUMN</span> status_changed_at;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>ALTER</span> <span style=color:#66d9ef>TABLE</span> purchase
</span></span><span style=display:flex><span><span style=color:#66d9ef>ADD</span> <span style=color:#66d9ef>COLUMN</span> pending_at <span style=color:#66d9ef>TIMESTAMP</span> <span style=color:#66d9ef>WITH</span> TIME <span style=color:#66d9ef>ZONE</span> <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span>,
</span></span><span style=display:flex><span><span style=color:#66d9ef>ADD</span> <span style=color:#66d9ef>COLUMN</span> settled_at <span style=color:#66d9ef>TIMESTAMP</span> <span style=color:#66d9ef>WITH</span> TIME <span style=color:#66d9ef>ZONE</span>,
</span></span><span style=display:flex><span><span style=color:#66d9ef>ADD</span> <span style=color:#66d9ef>COLUMN</span> dispatched_at <span style=color:#66d9ef>TIMESTAMP</span> <span style=color:#66d9ef>WITH</span> TIME <span style=color:#66d9ef>ZONE</span>,
</span></span><span style=display:flex><span><span style=color:#66d9ef>ADD</span> <span style=color:#66d9ef>COLUMN</span> delivered_at <span style=color:#66d9ef>TIMESTAMP</span> <span style=color:#66d9ef>WITH</span> TIME <span style=color:#66d9ef>ZONE</span>;
</span></span></code></pre></div><p>We can make <code>purchase.pending_at</code> non-null since rows will have this from the
beginning, but everything else must be nullable. We can then derive the status
from these columns:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>INSERT</span> <span style=color:#66d9ef>INTO</span> purchase (purchase_uid, created_at, pending_at)
</span></span><span style=display:flex><span><span style=color:#66d9ef>VALUES</span> (
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;d3b1ca3e-83b0-432b-81ea-330facdf7f56&#39;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;2025-05-04 09:13:54&#39;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;2025-05-04 09:13:57&#39;</span>
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>INSERT</span> <span style=color:#66d9ef>INTO</span> purchase (purchase_uid, created_at, pending_at, settled_at, dispatched_at)
</span></span><span style=display:flex><span><span style=color:#66d9ef>VALUES</span> (
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;decff56d-60cb-4368-9995-91768c3081dd&#39;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;2025-05-04 10:28:12&#39;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;2025-05-04 10:28:14&#39;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;2025-05-04 10:30:02&#39;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;2025-05-04 21:01:55&#39;</span>
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>SELECT</span>
</span></span><span style=display:flex><span>    purchase_uid,
</span></span><span style=display:flex><span>    created_at,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>CASE</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>WHEN</span> delivered_at <span style=color:#66d9ef>IS</span> <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span> <span style=color:#66d9ef>THEN</span> <span style=color:#e6db74>&#39;DELIVERED&#39;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>WHEN</span> dispatched_at <span style=color:#66d9ef>IS</span> <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span> <span style=color:#66d9ef>THEN</span> <span style=color:#e6db74>&#39;DISPATCHED&#39;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>WHEN</span> settled_at <span style=color:#66d9ef>IS</span> <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span> <span style=color:#66d9ef>THEN</span> <span style=color:#e6db74>&#39;SETTLED&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>ELSE</span>
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;PENDING&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>END</span> <span style=color:#66d9ef>AS</span> status
</span></span><span style=display:flex><span><span style=color:#66d9ef>FROM</span> purchase
</span></span><span style=display:flex><span><span style=color:#66d9ef>ORDER</span> <span style=color:#66d9ef>BY</span> created_at <span style=color:#66d9ef>ASC</span>;
</span></span></code></pre></div><p>This returns the following output:</p><pre tabindex=0><code>             purchase_uid             |       created_at       |   status
--------------------------------------+------------------------+------------
 d3b1ca3e-83b0-432b-81ea-330facdf7f56 | 2025-05-04 09:13:54+01 | PENDING
 decff56d-60cb-4368-9995-91768c3081dd | 2025-05-04 10:28:12+01 | DISPATCHED
</code></pre><p>While this is correct, it&rsquo;s quite a cumbersome approach:</p><ul><li>We&rsquo;re storing lots of <code>null</code> values if purchases don&rsquo;t progress</li><li>Since PostgreSQL implements an update as a delete and insert, we might be
creating lots of dead rows</li><li>Our <code>SELECT</code> statement doesn&rsquo;t even return the <code>status_changed_at</code> equivalent
at the moment, we&rsquo;d need a more complex query for that</li><li>The table will become quite wide over time</li><li>Any queries on status will need to use the same logic, leading to duplication</li></ul><h2 id=event-based-approach>Event-based Approach<a hidden class=anchor aria-hidden=true href=#event-based-approach>#</a></h2><p>Let&rsquo;s return to our <code>purchase</code> table definition from the beginning:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>DROP</span> <span style=color:#66d9ef>TABLE</span> purchase;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> purchase (
</span></span><span style=display:flex><span>    id BIGINT <span style=color:#66d9ef>GENERATED</span> ALWAYS <span style=color:#66d9ef>AS</span> <span style=color:#66d9ef>IDENTITY</span>,
</span></span><span style=display:flex><span>    purchase_uid UUID <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span>,
</span></span><span style=display:flex><span>    created_at <span style=color:#66d9ef>TIMESTAMP</span> <span style=color:#66d9ef>WITH</span> TIME <span style=color:#66d9ef>ZONE</span> <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>CONSTRAINT</span> pk_purchase <span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span> (id),
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>CONSTRAINT</span> uk_purchase_purchase_uid <span style=color:#66d9ef>UNIQUE</span> (purchase_uid)
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><p>A nicer model might be to represent each of these changes in state as an event, related to a purchase. We can insert these whenever something happens, such as the item being dispatched or delivered. We&rsquo;ll need a separate table with a foreign key:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TYPE</span> purchase_event_type <span style=color:#66d9ef>AS</span> ENUM (
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;PENDING&#39;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;SETTLED&#39;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;DISPATCHED&#39;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;DELIVERED&#39;</span>
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> purchase_event (
</span></span><span style=display:flex><span>    id BIGINT <span style=color:#66d9ef>GENERATED</span> ALWAYS <span style=color:#66d9ef>AS</span> <span style=color:#66d9ef>IDENTITY</span>,
</span></span><span style=display:flex><span>    purchase_event_uid UUID <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span>,
</span></span><span style=display:flex><span>    purchase_id BIGINT <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span>,
</span></span><span style=display:flex><span>    event_type purchase_event_type <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span>,
</span></span><span style=display:flex><span>    occurred_at <span style=color:#66d9ef>TIMESTAMP</span> <span style=color:#66d9ef>WITH</span> TIME <span style=color:#66d9ef>ZONE</span> <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>CONSTRAINT</span> pk_purchase_event <span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span> (id),
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>CONSTRAINT</span> uk_purchase_event_purchase_event_uid <span style=color:#66d9ef>UNIQUE</span> (purchase_event_uid),
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>CONSTRAINT</span> fk_purchase_event_purchase_id <span style=color:#66d9ef>FOREIGN</span> <span style=color:#66d9ef>KEY</span> (purchase_id) <span style=color:#66d9ef>REFERENCES</span> purchase (id)
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><p>This gives us a way to represent each change in state as an immutable event. When a
purchase is created, we insert a <code>PENDING</code> event:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>INSERT</span> <span style=color:#66d9ef>INTO</span> purchase (purchase_uid, created_at)
</span></span><span style=display:flex><span><span style=color:#66d9ef>VALUES</span> (
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;d3b1ca3e-83b0-432b-81ea-330facdf7f56&#39;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;2025-05-04 09:13:54&#39;</span>
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>INSERT</span> <span style=color:#66d9ef>INTO</span> purchase_event (purchase_event_uid, purchase_id, event_type, occurred_at)
</span></span><span style=display:flex><span><span style=color:#66d9ef>VALUES</span> (
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;a1f5e6d2-4c3b-4e29-9f7c-8b6d5e4f3a2b&#39;</span>,
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>SELECT</span> id <span style=color:#66d9ef>FROM</span> purchase <span style=color:#66d9ef>WHERE</span> purchase_uid <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;d3b1ca3e-83b0-432b-81ea-330facdf7f56&#39;</span>),
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;PENDING&#39;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;2025-05-04 09:13:57&#39;</span>
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><p>When the purchase is settled, we insert a <code>SETTLED</code> event:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>INSERT</span> <span style=color:#66d9ef>INTO</span> purchase_event (purchase_event_uid, purchase_id, event_type, occurred_at)
</span></span><span style=display:flex><span><span style=color:#66d9ef>VALUES</span> (
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;0d1d6b08-cdf5-42ef-810d-0bdba31017e2&#39;</span>,
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>SELECT</span> id <span style=color:#66d9ef>FROM</span> purchase <span style=color:#66d9ef>WHERE</span> purchase_uid <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;d3b1ca3e-83b0-432b-81ea-330facdf7f56&#39;</span>),
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;SETTLED&#39;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;2025-05-04 10:00:12&#39;</span>
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><p>We can continue this for each event in the purchase lifecycle. To get the current
status of a purchase, we can query the latest event:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> <span style=color:#66d9ef>DISTINCT</span> <span style=color:#66d9ef>ON</span> (p.purchase_uid)
</span></span><span style=display:flex><span>    p.purchase_uid,
</span></span><span style=display:flex><span>    p.created_at,
</span></span><span style=display:flex><span>    pe.event_type <span style=color:#66d9ef>AS</span> status,
</span></span><span style=display:flex><span>    pe.occurred_at <span style=color:#66d9ef>AS</span> status_changed_at
</span></span><span style=display:flex><span><span style=color:#66d9ef>FROM</span> purchase p
</span></span><span style=display:flex><span><span style=color:#66d9ef>JOIN</span> purchase_event pe <span style=color:#66d9ef>ON</span> pe.purchase_id <span style=color:#f92672>=</span> p.id
</span></span><span style=display:flex><span><span style=color:#66d9ef>WHERE</span> p.purchase_uid <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;d3b1ca3e-83b0-432b-81ea-330facdf7f56&#39;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>ORDER</span> <span style=color:#66d9ef>BY</span> p.purchase_uid, pe.occurred_at <span style=color:#66d9ef>DESC</span>;
</span></span></code></pre></div><p>We can also list all the events for a given purchase:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SELECT</span>
</span></span><span style=display:flex><span>    p.purchase_uid,
</span></span><span style=display:flex><span>    pe.event_type <span style=color:#66d9ef>AS</span> status,
</span></span><span style=display:flex><span>    pe.occurred_at <span style=color:#66d9ef>AS</span> status_changed_at
</span></span><span style=display:flex><span><span style=color:#66d9ef>FROM</span> purchase p
</span></span><span style=display:flex><span><span style=color:#66d9ef>JOIN</span> purchase_event pe <span style=color:#66d9ef>ON</span> pe.purchase_id <span style=color:#f92672>=</span> p.id
</span></span><span style=display:flex><span><span style=color:#66d9ef>WHERE</span> p.purchase_uid <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;d3b1ca3e-83b0-432b-81ea-330facdf7f56&#39;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>ORDER</span> <span style=color:#66d9ef>BY</span> pe.occurred_at;
</span></span></code></pre></div><p>The benefit of this approach is that we maintain a full history of all the
changes to a purchase, without losing any information. We can easily provide
metrics like how long purchases are taking to be delivered, and we can add new
event types in the future without modifying existing data.</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://alexander-jackson.github.io/></a></span>·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>