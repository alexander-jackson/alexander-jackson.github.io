<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Keep PostgreSQL Locks Short |</title><meta name=keywords content><meta name=description content="When dealing with a PostgreSQL database, locks are both a blessing and a curse.
Most of the time they get out of your way, coordinating transactions to make
sure they happen in the order you would expect and preventing concurrent data
updates.
However, locks can also be difficult to work with.
Needless Acquisitions
Let&rsquo;s consider the following migrations:
-- first migration
ALTER TABLE account
ADD COLUMN closed_at TIMESTAMP WITH TIME ZONE;
-- second migration
ALTER TABLE account
DROP COLUMN last_modified_at;
Altering a table requires an access exclusive lock on the table, which will
prevent any reads or writes at the same time, so it seems like a good idea to
acquire it and then release it as soon as possible by doing one operation at a
time."><meta name=author content><link rel=canonical href=https://alexander-jackson.github.io/posts/keep-postgresql-locks-short/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://alexander-jackson.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://alexander-jackson.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://alexander-jackson.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://alexander-jackson.github.io/apple-touch-icon.png><link rel=mask-icon href=https://alexander-jackson.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://alexander-jackson.github.io/posts/keep-postgresql-locks-short/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://alexander-jackson.github.io/posts/keep-postgresql-locks-short/"><meta property="og:title" content="Keep PostgreSQL Locks Short"><meta property="og:description" content="When dealing with a PostgreSQL database, locks are both a blessing and a curse. Most of the time they get out of your way, coordinating transactions to make sure they happen in the order you would expect and preventing concurrent data updates.
However, locks can also be difficult to work with.
Needless Acquisitions Let’s consider the following migrations:
-- first migration ALTER TABLE account ADD COLUMN closed_at TIMESTAMP WITH TIME ZONE; -- second migration ALTER TABLE account DROP COLUMN last_modified_at; Altering a table requires an access exclusive lock on the table, which will prevent any reads or writes at the same time, so it seems like a good idea to acquire it and then release it as soon as possible by doing one operation at a time."><meta property="og:locale" content="en-gb"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-12-01T14:27:13+00:00"><meta property="article:modified_time" content="2025-12-01T14:27:13+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Keep PostgreSQL Locks Short"><meta name=twitter:description content="When dealing with a PostgreSQL database, locks are both a blessing and a curse.
Most of the time they get out of your way, coordinating transactions to make
sure they happen in the order you would expect and preventing concurrent data
updates.
However, locks can also be difficult to work with.
Needless Acquisitions
Let&rsquo;s consider the following migrations:
-- first migration
ALTER TABLE account
ADD COLUMN closed_at TIMESTAMP WITH TIME ZONE;
-- second migration
ALTER TABLE account
DROP COLUMN last_modified_at;
Altering a table requires an access exclusive lock on the table, which will
prevent any reads or writes at the same time, so it seems like a good idea to
acquire it and then release it as soon as possible by doing one operation at a
time."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://alexander-jackson.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Keep PostgreSQL Locks Short","item":"https://alexander-jackson.github.io/posts/keep-postgresql-locks-short/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Keep PostgreSQL Locks Short","name":"Keep PostgreSQL Locks Short","description":"When dealing with a PostgreSQL database, locks are both a blessing and a curse. Most of the time they get out of your way, coordinating transactions to make sure they happen in the order you would expect and preventing concurrent data updates.\nHowever, locks can also be difficult to work with.\nNeedless Acquisitions Let\u0026rsquo;s consider the following migrations:\n-- first migration ALTER TABLE account ADD COLUMN closed_at TIMESTAMP WITH TIME ZONE; -- second migration ALTER TABLE account DROP COLUMN last_modified_at; Altering a table requires an access exclusive lock on the table, which will prevent any reads or writes at the same time, so it seems like a good idea to acquire it and then release it as soon as possible by doing one operation at a time.\n","keywords":[],"articleBody":"When dealing with a PostgreSQL database, locks are both a blessing and a curse. Most of the time they get out of your way, coordinating transactions to make sure they happen in the order you would expect and preventing concurrent data updates.\nHowever, locks can also be difficult to work with.\nNeedless Acquisitions Let’s consider the following migrations:\n-- first migration ALTER TABLE account ADD COLUMN closed_at TIMESTAMP WITH TIME ZONE; -- second migration ALTER TABLE account DROP COLUMN last_modified_at; Altering a table requires an access exclusive lock on the table, which will prevent any reads or writes at the same time, so it seems like a good idea to acquire it and then release it as soon as possible by doing one operation at a time.\nUnfortunately, this just means we release the lock and then immediately begin asking for it. Dropping a column on even a very large table should be a fast operation (since the database just marks the column as dropped without physically removing the data) so it’s usually a better idea to do both once you have the lock:\n-- single migration ALTER TABLE account ADD COLUMN closed_at TIMESTAMP WITH TIME ZONE; ALTER TABLE account DROP COLUMN last_modified_at; Since the first statement acquires the access exclusive lock, the second statement will run immediately instead of blocking and waiting for it. The transaction holds the lock, not the statement.\nAccidental Overextension When attempting to make changes to busy tables, we might use lock polling to avoid blocking other transactions for long periods of time:\nDO $$ BEGIN SET LOCAL LOCK_TIMEOUT TO '50ms'; LOOP BEGIN ALTER TABLE something_busy ADD COLUMN ...; RETURN; EXCEPTION WHEN LOCK_NOT_AVAILABLE THEN RAISE NOTICE 'Unable to obtain locks to alter public.something_busy, sleeping 2 seconds'; PERFORM PG_SLEEP(2); END; END LOOP; END; $$; This tells the database to wait at most 50ms to acquire the access exclusive lock we need to alter the table, and to wait at least 2 seconds after that times out. This allows other transactions to proceed in the meantime and prevents us causing a pile-up while we wait for the lock.\nHowever, this can have unexpected behaviour if you have multiple lock polling statements in the same migration:\nDO $$ BEGIN SET LOCAL LOCK_TIMEOUT TO '50ms'; LOOP BEGIN ALTER TABLE something_busy ADD COLUMN ...; RETURN; EXCEPTION WHEN LOCK_NOT_AVAILABLE THEN RAISE NOTICE 'Unable to obtain locks to alter public.something_busy, sleeping 2 seconds'; PERFORM PG_SLEEP(2); END; END LOOP; END; $$; DO $$ BEGIN SET LOCAL LOCK_TIMEOUT TO '50ms'; LOOP BEGIN ALTER TABLE something_also_really_busy ADD COLUMN ...; RETURN; EXCEPTION WHEN LOCK_NOT_AVAILABLE THEN RAISE NOTICE 'Unable to obtain locks to alter public.something_also_really_busy, sleeping 2 seconds'; PERFORM PG_SLEEP(2); END; END LOOP; END; $$; Here, we poll for an access exclusive lock on something_busy and then add a column to the table. Once done, we continue on and poll for an access exclusive lock on something_also_really_busy. Naively this seems sensible, we want to avoid blocking other transactions.\nThis goes badly wrong if there’s a long running transaction on something_also_really_busy though. If we don’t acquire the lock immediately, we’ll keep holding the access exclusive lock on something_busy while we continue to poll for the second one, blocking anything that wants to read from or write to the table.\nIn reality, these migrations should be separated into individual transactions:\n-- first migration, modify `something_busy` ... ALTER TABLE something_busy ADD COLUMN ...; ... -- second migration, modify `something_also_really_busy` ... ALTER TABLE something_also_really_busy ADD COLUMN ...; ... This ensures that the database releases the lock on something_busy before moving on to perform lock polling on something_also_really_busy, keeping the locks shorter.\n","wordCount":"600","inLanguage":"en","datePublished":"2025-12-01T14:27:13Z","dateModified":"2025-12-01T14:27:13Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://alexander-jackson.github.io/posts/keep-postgresql-locks-short/"},"publisher":{"@type":"Organization","name":"","logo":{"@type":"ImageObject","url":"https://alexander-jackson.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Keep PostgreSQL Locks Short</h1><div class=post-meta><span title='2025-12-01 14:27:13 +0000 UTC'>December 1, 2025</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#needless-acquisitions aria-label="Needless Acquisitions">Needless Acquisitions</a></li><li><a href=#accidental-overextension aria-label="Accidental Overextension">Accidental Overextension</a></li></ul></div></details></div><div class=post-content><p>When dealing with a PostgreSQL database, locks are both a blessing and a curse.
Most of the time they get out of your way, coordinating transactions to make
sure they happen in the order you would expect and preventing concurrent data
updates.</p><p>However, locks can also be difficult to work with.</p><h2 id=needless-acquisitions>Needless Acquisitions<a hidden class=anchor aria-hidden=true href=#needless-acquisitions>#</a></h2><p>Let&rsquo;s consider the following migrations:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#75715e>-- first migration
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>ALTER</span> <span style=color:#66d9ef>TABLE</span> account
</span></span><span style=display:flex><span><span style=color:#66d9ef>ADD</span> <span style=color:#66d9ef>COLUMN</span> closed_at <span style=color:#66d9ef>TIMESTAMP</span> <span style=color:#66d9ef>WITH</span> TIME <span style=color:#66d9ef>ZONE</span>;
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#75715e>-- second migration
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>ALTER</span> <span style=color:#66d9ef>TABLE</span> account
</span></span><span style=display:flex><span><span style=color:#66d9ef>DROP</span> <span style=color:#66d9ef>COLUMN</span> last_modified_at;
</span></span></code></pre></div><p>Altering a table requires an access exclusive lock on the table, which will
prevent any reads or writes at the same time, so it seems like a good idea to
acquire it and then release it as soon as possible by doing one operation at a
time.</p><p>Unfortunately, this just means we release the lock and then immediately begin
asking for it. Dropping a column on even a very large table should be a fast
operation (since the database just marks the column as dropped without
physically removing the data) so it&rsquo;s usually a better idea to do both once you
have the lock:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#75715e>-- single migration
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>ALTER</span> <span style=color:#66d9ef>TABLE</span> account
</span></span><span style=display:flex><span><span style=color:#66d9ef>ADD</span> <span style=color:#66d9ef>COLUMN</span> closed_at <span style=color:#66d9ef>TIMESTAMP</span> <span style=color:#66d9ef>WITH</span> TIME <span style=color:#66d9ef>ZONE</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>ALTER</span> <span style=color:#66d9ef>TABLE</span> account
</span></span><span style=display:flex><span><span style=color:#66d9ef>DROP</span> <span style=color:#66d9ef>COLUMN</span> last_modified_at;
</span></span></code></pre></div><p>Since the first statement acquires the access exclusive lock, the second
statement will run immediately instead of blocking and waiting for it. The
transaction holds the lock, not the statement.</p><h2 id=accidental-overextension>Accidental Overextension<a hidden class=anchor aria-hidden=true href=#accidental-overextension>#</a></h2><p>When attempting to make changes to busy tables, we might use lock polling to
avoid blocking other transactions for long periods of time:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>DO</span> <span style=color:#960050;background-color:#1e0010>$$</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>BEGIN</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>SET</span> <span style=color:#66d9ef>LOCAL</span> LOCK_TIMEOUT <span style=color:#66d9ef>TO</span> <span style=color:#e6db74>&#39;50ms&#39;</span>;
</span></span><span style=display:flex><span>  LOOP
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>BEGIN</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>ALTER</span> <span style=color:#66d9ef>TABLE</span> something_busy
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>ADD</span> <span style=color:#66d9ef>COLUMN</span> ...;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>RETURN</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>EXCEPTION</span> <span style=color:#66d9ef>WHEN</span> LOCK_NOT_AVAILABLE <span style=color:#66d9ef>THEN</span>
</span></span><span style=display:flex><span>      RAISE NOTICE <span style=color:#e6db74>&#39;Unable to obtain locks to alter public.something_busy, sleeping 2 seconds&#39;</span>;
</span></span><span style=display:flex><span>      PERFORM PG_SLEEP(<span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>END</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>END</span> LOOP;
</span></span><span style=display:flex><span><span style=color:#66d9ef>END</span>; <span style=color:#960050;background-color:#1e0010>$$</span>;
</span></span></code></pre></div><p>This tells the database to wait at most 50ms to acquire the access exclusive
lock we need to alter the table, and to wait at least 2 seconds after that
times out. This allows other transactions to proceed in the meantime and
prevents us causing a pile-up while we wait for the lock.</p><p>However, this can have unexpected behaviour if you have multiple lock polling
statements in the same migration:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>DO</span> <span style=color:#960050;background-color:#1e0010>$$</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>BEGIN</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>SET</span> <span style=color:#66d9ef>LOCAL</span> LOCK_TIMEOUT <span style=color:#66d9ef>TO</span> <span style=color:#e6db74>&#39;50ms&#39;</span>;
</span></span><span style=display:flex><span>  LOOP
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>BEGIN</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>ALTER</span> <span style=color:#66d9ef>TABLE</span> something_busy
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>ADD</span> <span style=color:#66d9ef>COLUMN</span> ...;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>RETURN</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>EXCEPTION</span> <span style=color:#66d9ef>WHEN</span> LOCK_NOT_AVAILABLE <span style=color:#66d9ef>THEN</span>
</span></span><span style=display:flex><span>      RAISE NOTICE <span style=color:#e6db74>&#39;Unable to obtain locks to alter public.something_busy, sleeping 2 seconds&#39;</span>;
</span></span><span style=display:flex><span>      PERFORM PG_SLEEP(<span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>END</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>END</span> LOOP;
</span></span><span style=display:flex><span><span style=color:#66d9ef>END</span>; <span style=color:#960050;background-color:#1e0010>$$</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>DO</span> <span style=color:#960050;background-color:#1e0010>$$</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>BEGIN</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>SET</span> <span style=color:#66d9ef>LOCAL</span> LOCK_TIMEOUT <span style=color:#66d9ef>TO</span> <span style=color:#e6db74>&#39;50ms&#39;</span>;
</span></span><span style=display:flex><span>  LOOP
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>BEGIN</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>ALTER</span> <span style=color:#66d9ef>TABLE</span> something_also_really_busy
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>ADD</span> <span style=color:#66d9ef>COLUMN</span> ...;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>RETURN</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>EXCEPTION</span> <span style=color:#66d9ef>WHEN</span> LOCK_NOT_AVAILABLE <span style=color:#66d9ef>THEN</span>
</span></span><span style=display:flex><span>      RAISE NOTICE <span style=color:#e6db74>&#39;Unable to obtain locks to alter public.something_also_really_busy, sleeping 2 seconds&#39;</span>;
</span></span><span style=display:flex><span>      PERFORM PG_SLEEP(<span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>END</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>END</span> LOOP;
</span></span><span style=display:flex><span><span style=color:#66d9ef>END</span>; <span style=color:#960050;background-color:#1e0010>$$</span>;
</span></span></code></pre></div><p>Here, we poll for an access exclusive lock on <code>something_busy</code> and then add a
column to the table. Once done, we continue on and poll for an access exclusive
lock on <code>something_also_really_busy</code>. Naively this seems sensible, we want to
avoid blocking other transactions.</p><p>This goes badly wrong if there&rsquo;s a long running transaction on
<code>something_also_really_busy</code> though. If we don&rsquo;t acquire the lock immediately,
we&rsquo;ll keep holding the access exclusive lock on <code>something_busy</code> while we
continue to poll for the second one, blocking anything that wants to read from
or write to the table.</p><p>In reality, these migrations should be separated into individual transactions:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#75715e>-- first migration, modify `something_busy`
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>...
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>ALTER</span> <span style=color:#66d9ef>TABLE</span> something_busy
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>ADD</span> <span style=color:#66d9ef>COLUMN</span> ...;
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#75715e>-- second migration, modify `something_also_really_busy`
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>...
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>ALTER</span> <span style=color:#66d9ef>TABLE</span> something_also_really_busy
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>ADD</span> <span style=color:#66d9ef>COLUMN</span> ...;
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>This ensures that the database releases the lock on <code>something_busy</code> before
moving on to perform lock polling on <code>something_also_really_busy</code>, keeping the
locks shorter.</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://alexander-jackson.github.io/></a></span>·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>