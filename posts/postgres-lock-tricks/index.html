<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Postgres Lock Tricks | </title><meta name=keywords content><meta name=description content="Postgres is a much loved relational database system that provides solid performance and reliability. However, the concurrency model that it provides (MVCC - multi-version concurrency control) can lead to some interesting observations.
How does MVCC work? Multi-version concurrency control is not a simple system to explain. It&rsquo;s worth reading the Postgres documentation if you&rsquo;re interested in going deeper with it, but this section aims to provide a small overview.
Read Committed Isolation Level This is the default value for transaction isolation in Postgres and the only one we&rsquo;ll be discussing in this article."><meta name=author content><link rel=canonical href=https://alexander-jackson.github.io/posts/postgres-lock-tricks/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://alexander-jackson.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://alexander-jackson.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://alexander-jackson.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://alexander-jackson.github.io/apple-touch-icon.png><link rel=mask-icon href=https://alexander-jackson.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://alexander-jackson.github.io/posts/postgres-lock-tricks/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Postgres Lock Tricks"><meta property="og:description" content="Postgres is a much loved relational database system that provides solid performance and reliability. However, the concurrency model that it provides (MVCC - multi-version concurrency control) can lead to some interesting observations.
How does MVCC work? Multi-version concurrency control is not a simple system to explain. It&rsquo;s worth reading the Postgres documentation if you&rsquo;re interested in going deeper with it, but this section aims to provide a small overview.
Read Committed Isolation Level This is the default value for transaction isolation in Postgres and the only one we&rsquo;ll be discussing in this article."><meta property="og:type" content="article"><meta property="og:url" content="https://alexander-jackson.github.io/posts/postgres-lock-tricks/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-08-24T17:25:00+01:00"><meta property="article:modified_time" content="2024-08-24T17:25:00+01:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Postgres Lock Tricks"><meta name=twitter:description content="Postgres is a much loved relational database system that provides solid performance and reliability. However, the concurrency model that it provides (MVCC - multi-version concurrency control) can lead to some interesting observations.
How does MVCC work? Multi-version concurrency control is not a simple system to explain. It&rsquo;s worth reading the Postgres documentation if you&rsquo;re interested in going deeper with it, but this section aims to provide a small overview.
Read Committed Isolation Level This is the default value for transaction isolation in Postgres and the only one we&rsquo;ll be discussing in this article."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://alexander-jackson.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Postgres Lock Tricks","item":"https://alexander-jackson.github.io/posts/postgres-lock-tricks/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Postgres Lock Tricks","name":"Postgres Lock Tricks","description":"Postgres is a much loved relational database system that provides solid performance and reliability. However, the concurrency model that it provides (MVCC - multi-version concurrency control) can lead to some interesting observations.\nHow does MVCC work? Multi-version concurrency control is not a simple system to explain. It\u0026rsquo;s worth reading the Postgres documentation if you\u0026rsquo;re interested in going deeper with it, but this section aims to provide a small overview.\nRead Committed Isolation Level This is the default value for transaction isolation in Postgres and the only one we\u0026rsquo;ll be discussing in this article.","keywords":[],"articleBody":"Postgres is a much loved relational database system that provides solid performance and reliability. However, the concurrency model that it provides (MVCC - multi-version concurrency control) can lead to some interesting observations.\nHow does MVCC work? Multi-version concurrency control is not a simple system to explain. It’s worth reading the Postgres documentation if you’re interested in going deeper with it, but this section aims to provide a small overview.\nRead Committed Isolation Level This is the default value for transaction isolation in Postgres and the only one we’ll be discussing in this article. The documentation states:\nWhen a transaction uses this isolation level, a SELECT query (without a FOR UPDATE/SHARE clause) sees only data committed before the query began; it never sees either uncommitted data or changes committed by concurrent transactions during the query’s execution.\nThe implication here is that if the following 2 commands are run:\n-- Thread 1 SELECT name FROM account WHERE id = 1 -- Thread 2 UPDATE account SET name = 'John' WHERE id = 1 then the first thread will only see the value John if the second thread has already committed its transaction when it starts its own. If the first thread has already started the transaction, it essentially sees a snapshot of the data. Even if there is work to be done before this SELECT command and thread 2 has committed by the time it is reached, it will still read John.\nThis is somewhat confused by the following:\n-- Thread 1 UPDATE account SET name = 'Mark' WHERE id = 1 SELECT name FROM account WHERE id = 1 In this sequence of events we only have a single thread. Despite the transaction not being committed when the SELECT command is executed, uncommitted writes are still viewable if is was that transaction that wrote them. This means the query will always return Mark in this case.\nTable-Level Locks Different commands and transactions require different levels of access to various database structures. For example, a command like ALTER TABLE account DROP COLUMN name requires exclusive access to the account table in order to prevent other transactions trying to read the data while it makes schema changes.\nSELECT id FROM account on the other hand needs very weak privileges, almost all other commands can be run at the same time due to the read-only behaviour.\nPostgres implements this access control using table-level locks. Each command requires a set of locks on one or more tables to be able to run, which allows for commands like ALTER TABLE to constrain themselves to exclusive access.\nSome commands may require locks on multiple tables or indexes. For example, the following command needs exclusive access on both the constrained (account_email) and referenced (account) tables in order to drop the foreign key:\nALTER TABLE account_email DROP CONSTRAINT fk_account_account_email This makes sense if you think about it, we need to update the table metadata on both sides to account for the resulting lack of the foreign key.\nConfusing Access Requirements However, not all locks are quite as obvious as you might expect. Let’s imagine we have some large tables in our application. We usually perform our schema migrations on application startup (using Flyway in Java for example) but we’d like to create an index concurrently to avoid blocking other database transactions.\nOur migration provider doesn’t support this, since you cannot create indexes concurrently within a transaction. Thus, we’re going to run this separately to application startup and add a migration script to create the index later if it doesn’t already exist.\nThe obvious way of doing this is:\nCREATE INDEX IF NOT EXISTS \u003cindex_name\u003e ON \u003ctable\u003e (\u003ccolumns\u003e) This does exactly what we want it to. If the index already exists, our migration will do nothing. If it doesn’t exist then we proceed and create it (non-concurrently, so likely only sensible for new databases or local development). We get our pull request merged and before we know it we’re off to production.\nUnfortunately, this doesn’t behave in the way we might expect.\nFootguns Let’s consider the following migration, presuming we have already created the index in a separate change, either on table creation or through an asynchronous process:\nCREATE INDEX IF NOT EXISTS idx_account_account_uid ON account (account_uid) We might expect that because the index already exists, this is a “free” operation. However, if we run another command in a separate transaction and don’t commit it:\nBEGIN; UPDATE account SET created_at = now()::timestamp WHERE id = ... Then we start to see some cracks. Our initial migration will just hang, seemingly doing nothing. This is because the UPDATE command we’re running is taking a RowExclusiveLock on the account table, and our CREATE INDEX IF NOT EXISTS command needs a ShareLock on the same table. These lock types conflict, so we’re essentially blocked until the UPDATE completes.\nThis is pretty surprising. The index already exists, so Postgres should be able to elide the creation and just do nothing, right? Unfortunately this isn’t how the implementation works, and it still needs to get the lock in order to check whether it needs to do anything.\nLock-Free Solutions Luckily, we can avoid locks in this scenario. Postgres exposes much of the database metadata in the catalog tables which we can use to query index data.\nFor example, the pg_index table contains all of the indexes in the system, so we can write something like:\nSELECT EXISTS ( SELECT FROM pg_index pi JOIN pg_class pc ON pc.oid = pi.indexrelid WHERE pc.relname = 'idx_account_account_uid' ) This will check the catalog tables and tell us if idx_account_account_uid already exists in the database. From here we can simply wrap our CREATE INDEX command in this check, which will allow us to avoid the creation if it does exist without taking any locks (outside of the catalog tables at least, which very rarely have locks on them).\n","wordCount":"978","inLanguage":"en","datePublished":"2024-08-24T17:25:00+01:00","dateModified":"2024-08-24T17:25:00+01:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://alexander-jackson.github.io/posts/postgres-lock-tricks/"},"publisher":{"@type":"Organization","name":"","logo":{"@type":"ImageObject","url":"https://alexander-jackson.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Postgres Lock Tricks</h1><div class=post-meta><span title='2024-08-24 17:25:00 +0100 +0100'>August 24, 2024</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#how-does-mvcc-work aria-label="How does MVCC work?">How does MVCC work?</a><ul><li><a href=#read-committed-isolation-level aria-label="Read Committed Isolation Level">Read Committed Isolation Level</a></li><li><a href=#table-level-locks aria-label="Table-Level Locks">Table-Level Locks</a></li><li><a href=#confusing-access-requirements aria-label="Confusing Access Requirements">Confusing Access Requirements</a></li><li><a href=#footguns aria-label=Footguns>Footguns</a></li><li><a href=#lock-free-solutions aria-label="Lock-Free Solutions">Lock-Free Solutions</a></li></ul></li></ul></div></details></div><div class=post-content><p>Postgres is a much loved relational database system that provides solid
performance and reliability. However, the concurrency model that it provides
(MVCC - multi-version concurrency control) can lead to some interesting
observations.</p><h2 id=how-does-mvcc-work>How does MVCC work?<a hidden class=anchor aria-hidden=true href=#how-does-mvcc-work>#</a></h2><p>Multi-version concurrency control is not a simple system to explain. It&rsquo;s worth
reading the <a href=https://www.postgresql.org/docs/current/mvcc.html>Postgres documentation</a> if you&rsquo;re interested in
going deeper with it, but this section aims to provide a small overview.</p><h3 id=read-committed-isolation-level>Read Committed Isolation Level<a hidden class=anchor aria-hidden=true href=#read-committed-isolation-level>#</a></h3><p>This is the default value for transaction isolation in Postgres and the only
one we&rsquo;ll be discussing in this article. The documentation states:</p><blockquote><p>When a transaction uses this isolation level, a <code>SELECT</code> query (without a
<code>FOR UPDATE/SHARE</code> clause) sees only data committed before the query began;
it never sees either uncommitted data or changes committed by concurrent
transactions during the query&rsquo;s execution.</p></blockquote><p>The implication here is that if the following 2 commands are run:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#75715e>-- Thread 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>SELECT</span> name <span style=color:#66d9ef>FROM</span> account <span style=color:#66d9ef>WHERE</span> id <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- Thread 2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>UPDATE</span> account <span style=color:#66d9ef>SET</span> name <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;John&#39;</span> <span style=color:#66d9ef>WHERE</span> id <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span></code></pre></div><p>then the first thread will only see the value <code>John</code> if the second thread has
already committed its transaction when it starts its own. If the first thread
has already started the transaction, it essentially sees a snapshot of the
data. Even if there is work to be done before this <code>SELECT</code> command and thread
2 has committed by the time it is reached, it will still read <code>John</code>.</p><p>This is somewhat confused by the following:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#75715e>-- Thread 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>UPDATE</span> account <span style=color:#66d9ef>SET</span> name <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;Mark&#39;</span> <span style=color:#66d9ef>WHERE</span> id <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> name <span style=color:#66d9ef>FROM</span> account <span style=color:#66d9ef>WHERE</span> id <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span></code></pre></div><p>In this sequence of events we only have a single thread. Despite the
transaction not being committed when the <code>SELECT</code> command is executed,
uncommitted writes are still viewable if is was that transaction that wrote
them. This means the query will always return <code>Mark</code> in this case.</p><h3 id=table-level-locks>Table-Level Locks<a hidden class=anchor aria-hidden=true href=#table-level-locks>#</a></h3><p>Different commands and transactions require different levels of access to
various database structures. For example, a command like <code>ALTER TABLE account DROP COLUMN name</code> requires exclusive access to the <code>account</code> table in order to
prevent other transactions trying to read the data while it makes schema
changes.</p><p><code>SELECT id FROM account</code> on the other hand needs very weak privileges, almost
all other commands can be run at the same time due to the read-only behaviour.</p><p>Postgres implements this access control using table-level locks. Each command
requires a set of locks on one or more tables to be able to run, which allows
for commands like <code>ALTER TABLE</code> to constrain themselves to exclusive access.</p><p>Some commands may require locks on multiple tables or indexes. For example, the
following command needs exclusive access on both the constrained
(<code>account_email</code>) and referenced (<code>account</code>) tables in order to drop the
foreign key:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>ALTER</span> <span style=color:#66d9ef>TABLE</span> account_email
</span></span><span style=display:flex><span><span style=color:#66d9ef>DROP</span> <span style=color:#66d9ef>CONSTRAINT</span> fk_account_account_email
</span></span></code></pre></div><p>This makes sense if you think about it, we need to update the table metadata on
both sides to account for the resulting lack of the foreign key.</p><h3 id=confusing-access-requirements>Confusing Access Requirements<a hidden class=anchor aria-hidden=true href=#confusing-access-requirements>#</a></h3><p>However, not all locks are quite as obvious as you might expect. Let&rsquo;s imagine
we have some large tables in our application. We usually perform our schema
migrations on application startup (using <a href=https://flywaydb.org>Flyway</a> in Java for example)
but we&rsquo;d like to create an index concurrently to avoid blocking other database
transactions.</p><p>Our migration provider doesn&rsquo;t support this, since you cannot create indexes
concurrently within a transaction. Thus, we&rsquo;re going to run this separately to
application startup and add a migration script to create the index later if it
doesn&rsquo;t already exist.</p><p>The obvious way of doing this is:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>INDEX</span> <span style=color:#66d9ef>IF</span> <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>EXISTS</span> <span style=color:#f92672>&lt;</span>index_name<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>ON</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>table</span><span style=color:#f92672>&gt;</span> (<span style=color:#f92672>&lt;</span>columns<span style=color:#f92672>&gt;</span>)
</span></span></code></pre></div><p>This does exactly what we want it to. If the index already exists, our
migration will do nothing. If it doesn&rsquo;t exist then we proceed and create it
(non-concurrently, so likely only sensible for new databases or local
development). We get our pull request merged and before we know it we&rsquo;re off to
production.</p><p>Unfortunately, this doesn&rsquo;t behave in the way we might expect.</p><h3 id=footguns>Footguns<a hidden class=anchor aria-hidden=true href=#footguns>#</a></h3><p>Let&rsquo;s consider the following migration, presuming we have already created the
index in a separate change, either on table creation or through an asynchronous
process:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>INDEX</span> <span style=color:#66d9ef>IF</span> <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>EXISTS</span> idx_account_account_uid
</span></span><span style=display:flex><span><span style=color:#66d9ef>ON</span> account (account_uid)
</span></span></code></pre></div><p>We might expect that because the index already exists, this is a &ldquo;free&rdquo;
operation. However, if we run another command in a separate transaction and
don&rsquo;t commit it:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>BEGIN</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>UPDATE</span> account
</span></span><span style=display:flex><span><span style=color:#66d9ef>SET</span> created_at <span style=color:#f92672>=</span> now()::<span style=color:#66d9ef>timestamp</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>WHERE</span> id <span style=color:#f92672>=</span> ...
</span></span></code></pre></div><p>Then we start to see some cracks. Our initial migration will just hang,
seemingly doing nothing. This is because the <code>UPDATE</code> command we&rsquo;re running is
taking a <code>RowExclusiveLock</code> on the <code>account</code> table, and our <code>CREATE INDEX IF NOT EXISTS</code> command needs a <code>ShareLock</code> on the same table. These lock types
conflict, so we&rsquo;re essentially blocked until the <code>UPDATE</code> completes.</p><p>This is pretty surprising. The index already exists, so Postgres should be able
to elide the creation and just do nothing, right? Unfortunately this isn&rsquo;t how
the implementation works, and it still needs to get the lock in order to check
whether it needs to do anything.</p><h3 id=lock-free-solutions>Lock-Free Solutions<a hidden class=anchor aria-hidden=true href=#lock-free-solutions>#</a></h3><p>Luckily, we can avoid locks in this scenario. Postgres exposes much of the
database metadata in the <a href=https://www.postgresql.org/docs/current/catalogs.html>catalog tables</a> which we can use to query index data.</p><p>For example, the <code>pg_index</code> table contains all of the indexes in the system, so
we can write something like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> <span style=color:#66d9ef>EXISTS</span> (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>SELECT</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>FROM</span> pg_index pi
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>JOIN</span> pg_class pc <span style=color:#66d9ef>ON</span> pc.oid <span style=color:#f92672>=</span> pi.indexrelid
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>WHERE</span> pc.relname <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;idx_account_account_uid&#39;</span>
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p>This will check the catalog tables and tell us if <code>idx_account_account_uid</code>
already exists in the database. From here we can simply wrap our <code>CREATE INDEX</code>
command in this check, which will allow us to avoid the creation if it does
exist without taking any locks (outside of the catalog tables at least, which
very rarely have locks on them).</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://alexander-jackson.github.io/></a></span><span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>