<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Storing Enums in PostgreSQL |</title><meta name=keywords content><meta name=description content="Enumerations (or enums) are a wonderful concept that are supported in the
majority of languages these days in some form or another. While a String can
store arbitrary text of any length, an enum represents a finite set of values
or variants.
These are extremely useful when considering database schema design as it allows
you to restrict the possible set of states your system can be in.
Take for example, an account table with a state field:"><meta name=author content><link rel=canonical href=https://alexander-jackson.github.io/posts/storing-enums-in-postgres/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://alexander-jackson.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://alexander-jackson.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://alexander-jackson.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://alexander-jackson.github.io/apple-touch-icon.png><link rel=mask-icon href=https://alexander-jackson.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://alexander-jackson.github.io/posts/storing-enums-in-postgres/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://alexander-jackson.github.io/posts/storing-enums-in-postgres/"><meta property="og:title" content="Storing Enums in PostgreSQL"><meta property="og:description" content="Enumerations (or enums) are a wonderful concept that are supported in the majority of languages these days in some form or another. While a String can store arbitrary text of any length, an enum represents a finite set of values or variants.
These are extremely useful when considering database schema design as it allows you to restrict the possible set of states your system can be in.
Take for example, an account table with a state field:"><meta property="og:locale" content="en-gb"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-04-05T06:41:01+00:00"><meta property="article:modified_time" content="2025-04-05T06:41:01+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Storing Enums in PostgreSQL"><meta name=twitter:description content="Enumerations (or enums) are a wonderful concept that are supported in the
majority of languages these days in some form or another. While a String can
store arbitrary text of any length, an enum represents a finite set of values
or variants.
These are extremely useful when considering database schema design as it allows
you to restrict the possible set of states your system can be in.
Take for example, an account table with a state field:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://alexander-jackson.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Storing Enums in PostgreSQL","item":"https://alexander-jackson.github.io/posts/storing-enums-in-postgres/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Storing Enums in PostgreSQL","name":"Storing Enums in PostgreSQL","description":"Enumerations (or enums) are a wonderful concept that are supported in the majority of languages these days in some form or another. While a String can store arbitrary text of any length, an enum represents a finite set of values or variants.\nThese are extremely useful when considering database schema design as it allows you to restrict the possible set of states your system can be in.\nTake for example, an account table with a state field:\n","keywords":[],"articleBody":"Enumerations (or enums) are a wonderful concept that are supported in the majority of languages these days in some form or another. While a String can store arbitrary text of any length, an enum represents a finite set of values or variants.\nThese are extremely useful when considering database schema design as it allows you to restrict the possible set of states your system can be in.\nTake for example, an account table with a state field:\npostgres=# CREATE TABLE account ( id BIGINT GENERATED ALWAYS AS IDENTITY, state TEXT NOT NULL ); CREATE TABLE Here, we’re storing our state using the TEXT datatype in PostgreSQL which means it could accept any string value. We can store all the ones we might expect:\nOPENED CLOSED SUSPENDED But also plenty of values we might not expect:\nOPEN CLOSING BANANAS Enum Types This sort of usage (where we know all the possible options) is much better suited to an enum-based representation. PostgreSQL does support enums:\npostgres=# CREATE TYPE account_state AS ENUM ('OPEN', 'CLOSED', 'SUSPENDED'); CREATE TYPE postgres=# CREATE TABLE account ( id BIGINT GENERATED ALWAYS AS IDENTITY, state account_state NOT NULL ); CREATE TABLE This forces the database to check the values on insertion and ensure that they match the enum:\npostgres=# INSERT INTO account (state) VALUES ('OPENED'); INSERT 0 1 postgres=# INSERT INTO account (state) VALUES ('OPEN'); ERROR: invalid input value for enum account_state: \"OPEN\" postgres=# SELECT * FROM account; id | state ----+------- 1 | OPENED (1 row) We can easily add new variants to the definition if we decide that we want to represent the state of an account before it gets approved:\npostgres=# ALTER TYPE account_state ADD VALUE 'PENDING'; However, if our data model changes and we decide that the SUSPENDED state isn’t needed anymore, it becomes a little more difficult. There’s no ALTER TYPE REMOVE VALUE command, as this would require working out whether the variant was used anywhere in the database. Even with an index, that could be a very expensive operation requiring locks on many different tables.\nWe can try and get around this by creating a new type with our reduced variant set and altering the type of the column in-place, although this does require some interesting casting from account_state to TEXT to account_state_new:\n-- create a new type with our variants postgres=# CREATE TYPE account_state_new AS ENUM ('OPENED', 'CLOSED', 'PENDING'); -- cast the existing column to the new type postgres=# ALTER TABLE account ALTER COLUMN state TYPE account_state_new USING state::TEXT::account_state_new; -- drop the old type postgres=# DROP TYPE account_state; -- rename the new one as part of tidying up postgres=# ALTER TYPE account_state_new RENAME TO account_state; This approach probably won’t work so well on a large table, since it will take an access exclusive lock on it. This will block all reads and writes while the database is either checking that the cast is valid (requiring reading every row) or rewriting everything. Neither of these methods are going to be fast.\nWe can actually do this in a much more dangerous way if we like. pg_enum stores metadata about defined enums and their variants, so we can look up the definition for the one we’d like to change:\npostgres=# SELECT pe.oid, pe.enumlabel, pt.typname FROM pg_enum pe JOIN pg_type pt ON pe.enumtypid = pt.oid; oid | enumlabel | typname --------+-----------+--------------- 804946 | PENDING | account_state 804940 | SUSPENDED | account_state 804938 | CLOSED | account_state 804936 | OPENED | account_state (4 rows) From here, we can just delete the value we no longer want in our type:\npostgres=# DELETE FROM pg_enum WHERE oid = 804940; DELETE 1 Note: do not do this. If the enum variant is still used anywhere in the database it is now corrupted.\nCheck Constraints Another option for constraining the data allowed in a column or table is a check constraint. If we return to our TEXT based state representation, we can add one of these onto the table:\npostgres=# CREATE TABLE account ( id BIGINT GENERATED ALWAYS AS IDENTITY, state TEXT NOT NULL, -- new, defining our check constraint CONSTRAINT chk_account_state CHECK (state = 'OPENED' OR state = 'CLOSED') ); CREATE TABLE This works largely the same as before, we can happily insert values if they’re valid and we get errors if not:\npostgres=# INSERT INTO account (state) VALUES ('OPENED'); INSERT 0 1 postgres=# INSERT INTO account (state) VALUES ('OPEN'); ERROR: new row for relation \"account\" violates check constraint \"chk_account_state\" DETAIL: Failing row contains (2, OPEN). postgres=# SELECT * FROM account; id | state ----+-------- 1 | OPENED (1 row) Adding new values becomes a bit more complicated though. Instead of just adding a new variant to the type, we’ll need to redefine the check constraint itself, drop the old one and then rename it:\n-- add the new constraint postgres=# ALTER TABLE account ADD CONSTRAINT chk_account_state_new CHECK (state = 'OPENED' OR state = 'CLOSED' OR state = 'PENDING'); -- drop the old constraint postgres=# ALTER TABLE account DROP CONSTRAINT chk_account_state; -- rename the new constraint postgres=# ALTER TABLE account RENAME CONSTRAINT chk_account_state_new TO chk_account_state; This is more fiddly than the enum-based approach, as well as being harder to review. We need to check that the old constraint is a subset of the new one in order to allow it to apply trivially.\nEven then, PostgreSQL is not clever enough to notice this and will still need to check the table data. This can be done asynchronously by adding the constraint as not valid and then validating it, but it’s definitely more of a headache than the enum version.\nRemoving a variant is the exact same process but in reverse:\n-- update any existing data postgres=# UPDATE account SET state = 'CLOSED' WHERE state = 'PENDING'; -- add the new constraint postgres=# ALTER TABLE account ADD CONSTRAINT chk_account_state_new CHECK (state = 'OPENED' OR state = 'CLOSED'); -- drop the old constraint postgres=# ALTER TABLE account DROP CONSTRAINT chk_account_state; -- rename the new constraint postgres=# ALTER TABLE account RENAME CONSTRAINT chk_account_state_new TO chk_account_state; Generally speaking, working with the constraints is pretty straightforward. While adding a variant is more difficult, it’s the same difficulty as removing a variant, and some automation it’s fairly safe to add and remove values.\nBe aware though, validating a check constraint on a large table can take a significant amount of time. You may want to pick a different approach if you are regularly adding or removing variants, as both operations will take an equal amount of time.\nReference Tables Another possibility is a reference table. These store a mapping of an id column and a name which represents the enum variant.\nCREATE TABLE account_state ( id BIGINT GENERATED ALWAYS AS IDENTITY, name TEXT NOT NULL, CONSTRAINT pk_account_state PRIMARY KEY (id), CONSTRAINT uk_account_state_name UNIQUE (name) ); We can then use a foreign key in our source table:\nCREATE TABLE account ( id BIGINT GENERATED ALWAYS AS IDENTITY, account_state_id BIGINT NOT NULL, -- new, defining our foreign key constraint CONSTRAINT fk_account_account_state_id FOREIGN KEY (account_state_id) REFERENCES account_state (id) ); Before we can create any data, we need to insert some values into our reference table:\nINSERT INTO account_state (name) VALUES ('OPENED'), ('CLOSED'); The syntax for insertions becomes a little more complicated, since we need to lookup the right id value from account_state:\nINSERT INTO account (account_state_id) VALUES ( (SELECT id FROM account_state WHERE name = 'OPENED') ); Querying the data is also a little more complicated as we need to join the tables together and rename the name column to make more sense:\nSELECT a.id, s.name AS account_state FROM account a JOIN account_state s ON a.account_state_id = s.id; id | account_state ----+--------------- 1 | OPENED (1 row) Adding values becomes very easy however, requiring a simple insert into the table:\nINSERT INTO account_state (name) VALUES ('PENDING'); Removing a value is a little more difficult, depending on the size of the tables using the enum table. If they’re small and you are certain the value is no longer being used, you can just delete it from the table:\nDELETE FROM account_state WHERE name = 'PENDING'; This will require PostgreSQL to validate that the id value corresponding to that name is no longer present in any of the tables with foreign keys. If these are large or do not have appropriate indexes then this has the potential to cause a lot of performance issues in the database.\nYou can also easily rename variants:\nUPDATE account_state SET name = 'PROCESSING' WHERE name = 'PENDING'; Conclusion PostgreSQL’s enum type is a great option by default, but the lack of ability to easily remove values from it makes it more difficult to use. It’s likely that as the schema evolves you will want to tweak these and it doesn’t provide as much flexibility as it could.\nCheck constraints are a little more complex to work with, but are symmetric in their difficulty to add or remove variants. With some automation they can be quite straightforward to manipulate, but they are less obvious to the developer and thus can cause mistakes to be caught later.\nReference tables make queries more complicated, but provide good ergonomics when adding and removing values in smaller databases. With support from indexes, you can still trivially remove values without taking long-lived database locks or causing performance issues.\n","wordCount":"1550","inLanguage":"en","datePublished":"2025-04-05T06:41:01Z","dateModified":"2025-04-05T06:41:01Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://alexander-jackson.github.io/posts/storing-enums-in-postgres/"},"publisher":{"@type":"Organization","name":"","logo":{"@type":"ImageObject","url":"https://alexander-jackson.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Storing Enums in PostgreSQL</h1><div class=post-meta><span title='2025-04-05 06:41:01 +0000 UTC'>April 5, 2025</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#enum-types aria-label="Enum Types">Enum Types</a></li><li><a href=#check-constraints aria-label="Check Constraints">Check Constraints</a></li><li><a href=#reference-tables aria-label="Reference Tables">Reference Tables</a></li><li><a href=#conclusion aria-label=Conclusion>Conclusion</a></li></ul></div></details></div><div class=post-content><p>Enumerations (or enums) are a wonderful concept that are supported in the
majority of languages these days in some form or another. While a <code>String</code> can
store arbitrary text of any length, an <code>enum</code> represents a finite set of values
or variants.</p><p>These are extremely useful when considering database schema design as it allows
you to restrict the possible set of states your system can be in.</p><p>Take for example, an <code>account</code> table with a <code>state</code> field:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span>postgres<span style=color:#f92672>=#</span> <span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> account (
</span></span><span style=display:flex><span>    id BIGINT <span style=color:#66d9ef>GENERATED</span> ALWAYS <span style=color:#66d9ef>AS</span> <span style=color:#66d9ef>IDENTITY</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>state</span> TEXT <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span>
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span>
</span></span></code></pre></div><p>Here, we&rsquo;re storing our state using the <code>TEXT</code> datatype in PostgreSQL which
means it could accept any string value. We can store all the ones we might
expect:</p><ul><li><code>OPENED</code></li><li><code>CLOSED</code></li><li><code>SUSPENDED</code></li></ul><p>But also plenty of values we might not expect:</p><ul><li><code>OPEN</code></li><li><code>CLOSING</code></li><li><code>BANANAS</code></li></ul><h3 id=enum-types>Enum Types<a hidden class=anchor aria-hidden=true href=#enum-types>#</a></h3><p>This sort of usage (where we know all the possible options) is much better
suited to an enum-based representation. PostgreSQL does support enums:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span>postgres<span style=color:#f92672>=#</span> <span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TYPE</span> account_state <span style=color:#66d9ef>AS</span> ENUM (<span style=color:#e6db74>&#39;OPEN&#39;</span>, <span style=color:#e6db74>&#39;CLOSED&#39;</span>, <span style=color:#e6db74>&#39;SUSPENDED&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TYPE</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>postgres<span style=color:#f92672>=#</span> <span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> account (
</span></span><span style=display:flex><span>    id BIGINT <span style=color:#66d9ef>GENERATED</span> ALWAYS <span style=color:#66d9ef>AS</span> <span style=color:#66d9ef>IDENTITY</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>state</span> account_state <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span>
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span>
</span></span></code></pre></div><p>This forces the database to check the values on insertion and ensure that they
match the enum:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span>postgres<span style=color:#f92672>=#</span> <span style=color:#66d9ef>INSERT</span> <span style=color:#66d9ef>INTO</span> account (<span style=color:#66d9ef>state</span>) <span style=color:#66d9ef>VALUES</span> (<span style=color:#e6db74>&#39;OPENED&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>INSERT</span> <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>postgres<span style=color:#f92672>=#</span> <span style=color:#66d9ef>INSERT</span> <span style=color:#66d9ef>INTO</span> account (<span style=color:#66d9ef>state</span>) <span style=color:#66d9ef>VALUES</span> (<span style=color:#e6db74>&#39;OPEN&#39;</span>);
</span></span><span style=display:flex><span>ERROR:  invalid <span style=color:#66d9ef>input</span> value <span style=color:#66d9ef>for</span> enum account_state: <span style=color:#e6db74>&#34;OPEN&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>postgres<span style=color:#f92672>=#</span> <span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> account;
</span></span><span style=display:flex><span> id <span style=color:#f92672>|</span> <span style=color:#66d9ef>state</span>
</span></span><span style=display:flex><span><span style=color:#75715e>----+-------
</span></span></span><span style=display:flex><span>  <span style=color:#ae81ff>1</span> <span style=color:#f92672>|</span> OPENED
</span></span><span style=display:flex><span>(<span style=color:#ae81ff>1</span> <span style=color:#66d9ef>row</span>)
</span></span></code></pre></div><p>We can easily add new variants to the definition if we decide that we want to
represent the state of an account before it gets approved:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span>postgres<span style=color:#f92672>=#</span> <span style=color:#66d9ef>ALTER</span> <span style=color:#66d9ef>TYPE</span> account_state <span style=color:#66d9ef>ADD</span> VALUE <span style=color:#e6db74>&#39;PENDING&#39;</span>;
</span></span></code></pre></div><p>However, if our data model changes and we decide that the <code>SUSPENDED</code> state
isn&rsquo;t needed anymore, it becomes a little more difficult. There&rsquo;s no <code>ALTER TYPE &lt;name> REMOVE VALUE &lt;variant></code> command, as this would require working out
whether the variant was used anywhere in the database. Even with an index, that
could be a very expensive operation requiring locks on many different tables.</p><p>We can try and get around this by creating a new type with our reduced variant
set and altering the type of the column in-place, although this does require
some interesting casting from <code>account_state</code> to <code>TEXT</code> to <code>account_state_new</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#75715e>-- create a new type with our variants
</span></span></span><span style=display:flex><span>postgres<span style=color:#f92672>=#</span> <span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TYPE</span> account_state_new <span style=color:#66d9ef>AS</span> ENUM (<span style=color:#e6db74>&#39;OPENED&#39;</span>, <span style=color:#e6db74>&#39;CLOSED&#39;</span>, <span style=color:#e6db74>&#39;PENDING&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- cast the existing column to the new type
</span></span></span><span style=display:flex><span>postgres<span style=color:#f92672>=#</span> <span style=color:#66d9ef>ALTER</span> <span style=color:#66d9ef>TABLE</span> account <span style=color:#66d9ef>ALTER</span> <span style=color:#66d9ef>COLUMN</span> <span style=color:#66d9ef>state</span> <span style=color:#66d9ef>TYPE</span> account_state_new <span style=color:#66d9ef>USING</span> <span style=color:#66d9ef>state</span>::TEXT::account_state_new;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- drop the old type
</span></span></span><span style=display:flex><span>postgres<span style=color:#f92672>=#</span> <span style=color:#66d9ef>DROP</span> <span style=color:#66d9ef>TYPE</span> account_state;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- rename the new one as part of tidying up
</span></span></span><span style=display:flex><span>postgres<span style=color:#f92672>=#</span> <span style=color:#66d9ef>ALTER</span> <span style=color:#66d9ef>TYPE</span> account_state_new <span style=color:#66d9ef>RENAME</span> <span style=color:#66d9ef>TO</span> account_state;
</span></span></code></pre></div><p>This approach probably won&rsquo;t work so well on a large table, since it will take
an access exclusive lock on it. This will block all reads and writes while the
database is either checking that the cast is valid (requiring reading every
row) or rewriting everything. Neither of these methods are going to be fast.</p><p>We can actually do this in a much more dangerous way if we like. <code>pg_enum</code>
stores metadata about defined enums and their variants, so we can look up the
definition for the one we&rsquo;d like to change:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span>postgres<span style=color:#f92672>=#</span> <span style=color:#66d9ef>SELECT</span> pe.oid, pe.enumlabel, pt.typname
</span></span><span style=display:flex><span><span style=color:#66d9ef>FROM</span> pg_enum pe
</span></span><span style=display:flex><span><span style=color:#66d9ef>JOIN</span> pg_type pt <span style=color:#66d9ef>ON</span> pe.enumtypid <span style=color:#f92672>=</span> pt.oid;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  oid   <span style=color:#f92672>|</span> enumlabel <span style=color:#f92672>|</span>    typname
</span></span><span style=display:flex><span><span style=color:#75715e>--------+-----------+---------------
</span></span></span><span style=display:flex><span> <span style=color:#ae81ff>804946</span> <span style=color:#f92672>|</span> PENDING   <span style=color:#f92672>|</span> account_state
</span></span><span style=display:flex><span> <span style=color:#ae81ff>804940</span> <span style=color:#f92672>|</span> SUSPENDED <span style=color:#f92672>|</span> account_state
</span></span><span style=display:flex><span> <span style=color:#ae81ff>804938</span> <span style=color:#f92672>|</span> CLOSED    <span style=color:#f92672>|</span> account_state
</span></span><span style=display:flex><span> <span style=color:#ae81ff>804936</span> <span style=color:#f92672>|</span> OPENED    <span style=color:#f92672>|</span> account_state
</span></span><span style=display:flex><span>(<span style=color:#ae81ff>4</span> <span style=color:#66d9ef>rows</span>)
</span></span></code></pre></div><p>From here, we can just delete the value we no longer want in our type:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span>postgres<span style=color:#f92672>=#</span> <span style=color:#66d9ef>DELETE</span> <span style=color:#66d9ef>FROM</span> pg_enum <span style=color:#66d9ef>WHERE</span> oid <span style=color:#f92672>=</span> <span style=color:#ae81ff>804940</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>DELETE</span> <span style=color:#ae81ff>1</span>
</span></span></code></pre></div><p>Note: do not do this. If the enum variant is still used anywhere in the
database it is now corrupted.</p><h3 id=check-constraints>Check Constraints<a hidden class=anchor aria-hidden=true href=#check-constraints>#</a></h3><p>Another option for constraining the data allowed in a column or table is a
check constraint. If we return to our <code>TEXT</code> based <code>state</code> representation, we
can add one of these onto the table:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span>postgres<span style=color:#f92672>=#</span> <span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> account (
</span></span><span style=display:flex><span>    id BIGINT <span style=color:#66d9ef>GENERATED</span> ALWAYS <span style=color:#66d9ef>AS</span> <span style=color:#66d9ef>IDENTITY</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>state</span> TEXT <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>-- new, defining our check constraint
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>CONSTRAINT</span> chk_account_state <span style=color:#66d9ef>CHECK</span> (<span style=color:#66d9ef>state</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;OPENED&#39;</span> <span style=color:#66d9ef>OR</span> <span style=color:#66d9ef>state</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;CLOSED&#39;</span>)
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span>
</span></span></code></pre></div><p>This works largely the same as before, we can happily insert values if they&rsquo;re
valid and we get errors if not:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span>postgres<span style=color:#f92672>=#</span> <span style=color:#66d9ef>INSERT</span> <span style=color:#66d9ef>INTO</span> account (<span style=color:#66d9ef>state</span>) <span style=color:#66d9ef>VALUES</span> (<span style=color:#e6db74>&#39;OPENED&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>INSERT</span> <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>postgres<span style=color:#f92672>=#</span> <span style=color:#66d9ef>INSERT</span> <span style=color:#66d9ef>INTO</span> account (<span style=color:#66d9ef>state</span>) <span style=color:#66d9ef>VALUES</span> (<span style=color:#e6db74>&#39;OPEN&#39;</span>);
</span></span><span style=display:flex><span>ERROR:  <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>row</span> <span style=color:#66d9ef>for</span> relation <span style=color:#e6db74>&#34;account&#34;</span> violates <span style=color:#66d9ef>check</span> <span style=color:#66d9ef>constraint</span> <span style=color:#e6db74>&#34;chk_account_state&#34;</span>
</span></span><span style=display:flex><span>DETAIL:  Failing <span style=color:#66d9ef>row</span> <span style=color:#66d9ef>contains</span> (<span style=color:#ae81ff>2</span>, <span style=color:#66d9ef>OPEN</span>).
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>postgres<span style=color:#f92672>=#</span> <span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> account;
</span></span><span style=display:flex><span> id <span style=color:#f92672>|</span> <span style=color:#66d9ef>state</span>
</span></span><span style=display:flex><span><span style=color:#75715e>----+--------
</span></span></span><span style=display:flex><span>  <span style=color:#ae81ff>1</span> <span style=color:#f92672>|</span> OPENED
</span></span><span style=display:flex><span>(<span style=color:#ae81ff>1</span> <span style=color:#66d9ef>row</span>)
</span></span></code></pre></div><p>Adding new values becomes a bit more complicated though. Instead of just adding
a new variant to the type, we&rsquo;ll need to redefine the check constraint itself,
drop the old one and then rename it:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#75715e>-- add the new constraint
</span></span></span><span style=display:flex><span>postgres<span style=color:#f92672>=#</span> <span style=color:#66d9ef>ALTER</span> <span style=color:#66d9ef>TABLE</span> account
</span></span><span style=display:flex><span><span style=color:#66d9ef>ADD</span> <span style=color:#66d9ef>CONSTRAINT</span> chk_account_state_new
</span></span><span style=display:flex><span><span style=color:#66d9ef>CHECK</span> (<span style=color:#66d9ef>state</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;OPENED&#39;</span> <span style=color:#66d9ef>OR</span> <span style=color:#66d9ef>state</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;CLOSED&#39;</span> <span style=color:#66d9ef>OR</span> <span style=color:#66d9ef>state</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;PENDING&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- drop the old constraint
</span></span></span><span style=display:flex><span>postgres<span style=color:#f92672>=#</span> <span style=color:#66d9ef>ALTER</span> <span style=color:#66d9ef>TABLE</span> account <span style=color:#66d9ef>DROP</span> <span style=color:#66d9ef>CONSTRAINT</span> chk_account_state;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- rename the new constraint
</span></span></span><span style=display:flex><span>postgres<span style=color:#f92672>=#</span> <span style=color:#66d9ef>ALTER</span> <span style=color:#66d9ef>TABLE</span> account
</span></span><span style=display:flex><span><span style=color:#66d9ef>RENAME</span> <span style=color:#66d9ef>CONSTRAINT</span> chk_account_state_new
</span></span><span style=display:flex><span><span style=color:#66d9ef>TO</span> chk_account_state;
</span></span></code></pre></div><p>This is more fiddly than the enum-based approach, as well as being harder to
review. We need to check that the old constraint is a subset of the new one in
order to allow it to apply trivially.</p><p>Even then, PostgreSQL is not clever enough to notice this and will still need
to check the table data. This can be done asynchronously by adding the
constraint as not valid and then validating it, but it&rsquo;s definitely more of a
headache than the enum version.</p><p>Removing a variant is the exact same process but in reverse:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#75715e>-- update any existing data
</span></span></span><span style=display:flex><span>postgres<span style=color:#f92672>=#</span> <span style=color:#66d9ef>UPDATE</span> account <span style=color:#66d9ef>SET</span> <span style=color:#66d9ef>state</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;CLOSED&#39;</span> <span style=color:#66d9ef>WHERE</span> <span style=color:#66d9ef>state</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;PENDING&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- add the new constraint
</span></span></span><span style=display:flex><span>postgres<span style=color:#f92672>=#</span> <span style=color:#66d9ef>ALTER</span> <span style=color:#66d9ef>TABLE</span> account
</span></span><span style=display:flex><span><span style=color:#66d9ef>ADD</span> <span style=color:#66d9ef>CONSTRAINT</span> chk_account_state_new
</span></span><span style=display:flex><span><span style=color:#66d9ef>CHECK</span> (<span style=color:#66d9ef>state</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;OPENED&#39;</span> <span style=color:#66d9ef>OR</span> <span style=color:#66d9ef>state</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;CLOSED&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- drop the old constraint
</span></span></span><span style=display:flex><span>postgres<span style=color:#f92672>=#</span> <span style=color:#66d9ef>ALTER</span> <span style=color:#66d9ef>TABLE</span> account <span style=color:#66d9ef>DROP</span> <span style=color:#66d9ef>CONSTRAINT</span> chk_account_state;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- rename the new constraint
</span></span></span><span style=display:flex><span>postgres<span style=color:#f92672>=#</span> <span style=color:#66d9ef>ALTER</span> <span style=color:#66d9ef>TABLE</span> account
</span></span><span style=display:flex><span><span style=color:#66d9ef>RENAME</span> <span style=color:#66d9ef>CONSTRAINT</span> chk_account_state_new
</span></span><span style=display:flex><span><span style=color:#66d9ef>TO</span> chk_account_state;
</span></span></code></pre></div><p>Generally speaking, working with the constraints is pretty straightforward.
While adding a variant is more difficult, it&rsquo;s the same difficulty as removing
a variant, and some automation it&rsquo;s fairly safe to add and remove values.</p><p>Be aware though, validating a check constraint on a large table can take a
significant amount of time. You may want to pick a different approach if you
are regularly adding or removing variants, as both operations will take an
equal amount of time.</p><h3 id=reference-tables>Reference Tables<a hidden class=anchor aria-hidden=true href=#reference-tables>#</a></h3><p>Another possibility is a reference table. These store a mapping of an <code>id</code>
column and a <code>name</code> which represents the enum variant.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> account_state (
</span></span><span style=display:flex><span>    id BIGINT <span style=color:#66d9ef>GENERATED</span> ALWAYS <span style=color:#66d9ef>AS</span> <span style=color:#66d9ef>IDENTITY</span>,
</span></span><span style=display:flex><span>    name TEXT <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>CONSTRAINT</span> pk_account_state <span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span> (id),
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>CONSTRAINT</span> uk_account_state_name <span style=color:#66d9ef>UNIQUE</span> (name)
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><p>We can then use a foreign key in our source table:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> account (
</span></span><span style=display:flex><span>    id BIGINT <span style=color:#66d9ef>GENERATED</span> ALWAYS <span style=color:#66d9ef>AS</span> <span style=color:#66d9ef>IDENTITY</span>,
</span></span><span style=display:flex><span>    account_state_id BIGINT <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>-- new, defining our foreign key constraint
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>CONSTRAINT</span> fk_account_account_state_id
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>FOREIGN</span> <span style=color:#66d9ef>KEY</span> (account_state_id)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>REFERENCES</span> account_state (id)
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><p>Before we can create any data, we need to insert some values into our reference
table:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>INSERT</span> <span style=color:#66d9ef>INTO</span> account_state (name) <span style=color:#66d9ef>VALUES</span> (<span style=color:#e6db74>&#39;OPENED&#39;</span>), (<span style=color:#e6db74>&#39;CLOSED&#39;</span>);
</span></span></code></pre></div><p>The syntax for insertions becomes a little more complicated, since we need to
lookup the right <code>id</code> value from <code>account_state</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>INSERT</span> <span style=color:#66d9ef>INTO</span> account (account_state_id)
</span></span><span style=display:flex><span><span style=color:#66d9ef>VALUES</span> (
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>SELECT</span> id <span style=color:#66d9ef>FROM</span> account_state <span style=color:#66d9ef>WHERE</span> name <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;OPENED&#39;</span>)
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><p>Querying the data is also a little more complicated as we need to join the
tables together and rename the <code>name</code> column to make more sense:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> a.id, s.name <span style=color:#66d9ef>AS</span> account_state
</span></span><span style=display:flex><span><span style=color:#66d9ef>FROM</span> account a
</span></span><span style=display:flex><span><span style=color:#66d9ef>JOIN</span> account_state s <span style=color:#66d9ef>ON</span> a.account_state_id <span style=color:#f92672>=</span> s.id;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> id <span style=color:#f92672>|</span> account_state
</span></span><span style=display:flex><span><span style=color:#75715e>----+---------------
</span></span></span><span style=display:flex><span>  <span style=color:#ae81ff>1</span> <span style=color:#f92672>|</span> OPENED
</span></span><span style=display:flex><span>(<span style=color:#ae81ff>1</span> <span style=color:#66d9ef>row</span>)
</span></span></code></pre></div><p>Adding values becomes very easy however, requiring a simple insert into the
table:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>INSERT</span> <span style=color:#66d9ef>INTO</span> account_state (name) <span style=color:#66d9ef>VALUES</span> (<span style=color:#e6db74>&#39;PENDING&#39;</span>);
</span></span></code></pre></div><p>Removing a value is a little more difficult, depending on the size of the
tables using the enum table. If they&rsquo;re small and you are certain the value is
no longer being used, you can just delete it from the table:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>DELETE</span> <span style=color:#66d9ef>FROM</span> account_state <span style=color:#66d9ef>WHERE</span> name <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;PENDING&#39;</span>;
</span></span></code></pre></div><p>This will require PostgreSQL to validate that the <code>id</code> value corresponding to
that name is no longer present in any of the tables with foreign keys. If these
are large or do not have appropriate indexes then this has the potential to
cause a lot of performance issues in the database.</p><p>You can also easily rename variants:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>UPDATE</span> account_state <span style=color:#66d9ef>SET</span> name <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;PROCESSING&#39;</span> <span style=color:#66d9ef>WHERE</span> name <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;PENDING&#39;</span>;
</span></span></code></pre></div><h3 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h3><p>PostgreSQL&rsquo;s <code>enum</code> type is a great option by default, but the lack of ability
to easily remove values from it makes it more difficult to use. It&rsquo;s likely
that as the schema evolves you will want to tweak these and it doesn&rsquo;t provide
as much flexibility as it could.</p><p>Check constraints are a little more complex to work with, but are symmetric in
their difficulty to add or remove variants. With some automation they can be
quite straightforward to manipulate, but they are less obvious to the developer
and thus can cause mistakes to be caught later.</p><p>Reference tables make queries more complicated, but provide good ergonomics
when adding and removing values in smaller databases. With support from
indexes, you can still trivially remove values without taking long-lived
database locks or causing performance issues.</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://alexander-jackson.github.io/></a></span>·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>